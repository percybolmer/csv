// package terminalprocessors is generated by generate-processor tooling
// Make sure to insert real Description here
package terminalprocessors


import (
    "context"
    "fmt"
    "github.com/percybolmer/workflow/failure"
    "github.com/percybolmer/workflow/metric"
    "github.com/percybolmer/workflow/properties"
    "github.com/percybolmer/workflow/processors/processmanager"
    "github.com/percybolmer/workflow/relationships"

)
// Stdout is print the payload to stdout
type Stdout struct{
    Name     string
    running  bool
    cancel   context.CancelFunc
    ingress  relationships.PayloadChannel
    egress   relationships.PayloadChannel
    failures relationships.FailurePipe
    *properties.PropertyMap
    *metric.Metrics

    forward bool
}
// init is used to Register the processor to the processmanager
func init() {
    err := processmanager.RegisterProcessor("Stdout", NewStdoutInterface)
    if err != nil {
    panic(err)
    }
}
// NewStdoutInterface is used to return the Proccssor as interface
// This is to avoid Cyclic imports, we are not allowed to return processors.Processor
// so, let processmanager deal with the type assertion
func NewStdoutInterface() interface{} {
    return NewStdout()
}

// NewStdout is used to initialize and generate a new processor
func NewStdout() *Stdout {
    proc := &Stdout{
        egress: make(relationships.PayloadChannel, 1000),
        PropertyMap: properties.NewPropertyMap(),
        Metrics: metric.NewMetrics(),
    }

    // Add Required Props -- remove_after
    //proc.AddRequirement("your_property_names")
    return proc
}

// Initialize will make sure all needed Properties and Metrics are generated
func (proc *Stdout) Initialize() error {

    // Make sure Properties are there
    ok, _ := proc.ValidateProperties()
    if !ok {
        return properties.ErrRequiredPropertiesNotFulfilled
    }

    // See if the Payloads that is sendt here should be forwarded
    forProp := proc.GetProperty("forward")
    if forProp != nil {
        b, err := forProp.Bool()
        if err != nil {
            return err
        }
        proc.forward = b
    }

    return nil
}

// Start will spawn a goroutine that reads file and Exits either on Context.Done or When processing is finished
func (proc *Stdout) Start(ctx context.Context) error {
    if proc.running {
        return failure.ErrAlreadyRunning
    }
    // Uncomment if u need to Processor to require an Ingress relationship
    if proc.ingress == nil {
        return failure.ErrIngressRelationshipNeeded
    }

    proc.running = true
    // context will be used to spawn a Cancel func
    c, cancel := context.WithCancel(ctx)
    proc.cancel = cancel
    go func() {
        for {
            select {
                case payload := <-proc.ingress:
                    proc.AddMetric("payloads-printed", "a number of how many payloads has been printed", 1)
                    fmt.Println(payload.GetPayload())

                    if proc.forward {
                        proc.egress <- payload
                    }
                case <- c.Done():
                    return
            }
        }
    }()
    return nil
}

// IsRunning will return true or false based on if the processor is currently running
func (proc *Stdout) IsRunning() bool {
    return proc.running
}
// GetMetrics will return a bunch of generated metrics, or nil if there isn't any
func (proc *Stdout) GetMetrics() []*metric.Metric {
    return proc.GetAllMetrics()
}
// SetFailureChannel will configure the failure channel of the Processor
func (proc *Stdout) SetFailureChannel(fp relationships.FailurePipe) {
    proc.failures = fp
}

// Stop will stop the processing
func (proc *Stdout) Stop() {
    if !proc.running {
        return
    }
    proc.running = false
    proc.cancel()
}
// SetIngress will change the ingress of the processor, Restart is needed before applied changes
func (proc *Stdout) SetIngress(i relationships.PayloadChannel) {
    proc.ingress = i
    return
}
// GetEgress will return an Egress that is used to output the processed items
func (proc *Stdout) GetEgress() relationships.PayloadChannel {
    return proc.egress
}