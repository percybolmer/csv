// package {{.PackageName}} is generated by generate-processor tooling
// Make sure to insert real Description here
package {{.PackageName}}


import (
    "context"
    "github.com/percybolmer/workflow/failure"
    "github.com/percybolmer/workflow/metric"
    "github.com/percybolmer/workflow/properties"
    "github.com/percybolmer/workflow/processors/processmanager"
    "github.com/percybolmer/workflow/relationships"

)
// {{.ProcessorName}} is used to $INSERT DESCRIPTION
type {{.ProcessorName}} struct{
    Name     string `json:"name,omitempty" yaml:"name,omitempty"`
    running  bool
    cancel   context.CancelFunc
    ingress  relationships.PayloadChannel
    egress   relationships.PayloadChannel
    failures relationships.FailurePipe
    *properties.PropertyMap `json:"properties,omitempty" yaml:"properties,omitempty"`
    *metric.Metrics `json:"metrics,omitempty" yaml:",inline,omitempty"`
}
// init is used to Register the processor to the processmanager
func init() {
    err := processmanager.RegisterProcessor("{{.ProcessorName}}", New{{.ProcessorName}}Interface)
    if err != nil {
    panic(err)
    }
}
// New{{.ProcessorName}}Interface is used to return the Proccssor as interface
// This is to avoid Cyclic imports, we are not allowed to return processors.Processor
// so, let processmanager deal with the type assertion
func New{{.ProcessorName}}Interface() interface{} {
    return New{{.ProcessorName}}()
}

// New{{.ProcessorName}} is used to initialize and generate a new processor
func New{{.ProcessorName}}() *{{.ProcessorName}} {
    proc := &{{.ProcessorName}}{
        egress: make(relationships.PayloadChannel, 1000),
        PropertyMap: properties.NewPropertyMap(),
        Metrics: metric.NewMetrics(),
    }
    // Add AvailableProperties
    proc.AddAvailableProperty("your_property_name", "property is used to configure something")
    // Add Required Props -- remove_after
    // proc.AddRequirement("your_property_names")
    return proc
}

// Initialize will make sure all needed Properties and Metrics are generated
func (proc *{{.ProcessorName}}) Initialize() error {

    // Make sure Properties are there
    ok, _ := proc.ValidateProperties()
    if !ok {
        return properties.ErrRequiredPropertiesNotFulfilled
    }
    // If you need to read data from Properties and add to your Processor struct, this is the place to do it
    return nil
}

// Start will spawn a goroutine that reads file and Exits either on Context.Done or When processing is finished
func (proc *{{.ProcessorName}}) Start(ctx context.Context) error {
    if proc.running {
        return failure.ErrAlreadyRunning
    }
    // Uncomment if u need to Processor to require an Ingress relationship
    //if proc.ingress == nil {
    //    return failure.ErrIngressRelationshipNeeded
    //}

    proc.running = true
    // context will be used to spawn a Cancel func
    c, cancel := context.WithCancel(ctx)
    proc.cancel = cancel
    go func() {
        for {
            select {
                case payload := <-proc.ingress:
                    // Do your processing here
                    payload.GetPayload()
                    // Also add any metrics u want
                    proc.AddMetric("test", "description", 1)

                case <- c.Done():
                    return
            }
        }
    }()
    return nil
}

// IsRunning will return true or false based on if the processor is currently running
func (proc *{{.ProcessorName}}) IsRunning() bool {
    return proc.running
}
// GetMetrics will return a bunch of generated metrics, or nil if there isn't any
func (proc *{{.ProcessorName}}) GetMetrics() []*metric.Metric {
    return proc.GetAllMetrics()
}
// SetFailureChannel will configure the failure channel of the Processor
func (proc *{{.ProcessorName}}) SetFailureChannel(fp relationships.FailurePipe) {
    proc.failures = fp
}

// Stop will stop the processing
func (proc *{{.ProcessorName}}) Stop() {
    if !proc.running {
        return
    }
    proc.running = false
    proc.cancel()
}
// SetIngress will change the ingress of the processor, Restart is needed before applied changes
func (proc *{{.ProcessorName}}) SetIngress(i relationships.PayloadChannel) {
    proc.ingress = i
    return
}
// GetEgress will return an Egress that is used to output the processed items
func (proc *{{.ProcessorName}}) GetEgress() relationships.PayloadChannel {
    return proc.egress
}