import { __decorate, __param } from 'tslib';
import { ElementRef, Renderer2, Host, Self, Optional, Inject, forwardRef, Input, Directive, NgModule } from '@angular/core';
import { MatSidenav, MatDrawer, MatSidenavContainer, MatDrawerContainer, MatSidenavModule } from '@angular/material/sidenav';
import { style, group, query, animateChild, animate, AnimationBuilder } from '@angular/animations';
import { Subject } from 'rxjs';
import { takeUntil } from 'rxjs/operators';
import { Directionality } from '@angular/cdk/bidi';

var miniConfig = {
    defaultDuration: '100ms',
    defaultMinWidth: '60px',
    defaultMaxWidth: '200px',
};

function sidebarClose(minWidth) {
    if (minWidth === void 0) { minWidth = miniConfig.defaultMinWidth; }
    return style({
        width: minWidth,
        visibility: 'visible',
        transform: 'none',
        overflow: 'hidden'
    });
}
function sidebarOpen(maxWidth) {
    if (maxWidth === void 0) { maxWidth = miniConfig.defaultMaxWidth; }
    return style({
        width: maxWidth,
        visibility: 'visible',
    });
}
function sidebarAnimationOpenGroup(animationDuration, maxWidth) {
    if (animationDuration === void 0) { animationDuration = miniConfig.defaultDuration; }
    if (maxWidth === void 0) { maxWidth = miniConfig.defaultMaxWidth; }
    return group([
        query('@iconAnimation', animateChild(), { optional: true }),
        query('@labelAnimation', animateChild(), { optional: true }),
        animate(animationDuration + " ease-in-out", sidebarOpen(maxWidth))
    ]);
}
function sidebarAnimationCloseGroup(animationDuration, minWidth) {
    if (animationDuration === void 0) { animationDuration = miniConfig.defaultDuration; }
    if (minWidth === void 0) { minWidth = miniConfig.defaultMinWidth; }
    return group([
        query('@iconAnimation', animateChild(), { optional: true }),
        query('@labelAnimation', animateChild(), { optional: true }),
        animate(animationDuration + " ease-in-out", sidebarClose(minWidth))
    ]);
}

var MatDrawerRailDirective = /** @class */ (function () {
    function MatDrawerRailDirective(builder, el, renderer2, sidenav, drawer, matSideNavContainer, matDrawerContainer, 
    // tslint:disable-next-line: variable-name
    _dir) {
        this.builder = builder;
        this.el = el;
        this.renderer2 = renderer2;
        this._dir = _dir;
        this.onDestory = new Subject();
        this.closeWidth = miniConfig.defaultMinWidth;
        this.expandedWidth = miniConfig.defaultMaxWidth;
        this.container = matSideNavContainer || matDrawerContainer;
        this.drawer = sidenav || drawer;
        this.container.hasBackdrop = false;
        this.drawer.autoFocus = false;
    }
    MatDrawerRailDirective.prototype.ngOnInit = function () {
        var _this = this;
        this.closeAnimation = this.closeAnimation || sidebarAnimationCloseGroup(miniConfig.defaultDuration, this.closeWidth);
        this.openAnimation = this.openAnimation || sidebarAnimationOpenGroup(miniConfig.defaultDuration, this.expandedWidth);
        this.renderer2.setStyle(this.el.nativeElement.querySelector('.mat-drawer-inner-container'), 'overflow', 'hidden');
        this.drawer.closedStart.pipe(takeUntil(this.onDestory)).subscribe(function () {
            _this.closeMenu();
        });
        this.drawer._closedStream.pipe(takeUntil(this.onDestory)).subscribe(function () {
            _this.renderer2.setStyle(_this.el.nativeElement, 'visibility', 'visible');
        });
        this.drawer.openedStart.pipe(takeUntil(this.onDestory)).subscribe(function () {
            _this.correctContentMargin(_this.expandedWidth);
            var factory = _this.builder.build(_this.openAnimation);
            var player = factory.create(_this.el.nativeElement);
            player.play();
        });
    };
    MatDrawerRailDirective.prototype.ngAfterViewInit = function () {
        if (this.drawer.opened) {
            this.correctContentMargin(this.expandedWidth);
        }
        else {
            this.renderer2.setStyle(this.el.nativeElement, 'visibility', 'visible');
            this.closeMenu();
        }
    };
    MatDrawerRailDirective.prototype.closeMenu = function () {
        this.correctContentMargin(this.closeWidth);
        var factory = this.builder.build(this.closeAnimation);
        var player = factory.create(this.el.nativeElement);
        player.play();
    };
    MatDrawerRailDirective.prototype.correctContentMargin = function (width) {
        this.containerContent = this.containerContent ? this.containerContent : this.el.nativeElement.parentElement.querySelector('.mat-drawer-content');
        if ((this.drawer.position !== 'end' && this._dir && this._dir.value !== 'rtl')
            || (this.drawer.position === 'end' && this._dir && this._dir.value === 'rtl')) {
            this.renderer2.setStyle(this.containerContent, 'marginLeft', width);
        }
        else {
            this.renderer2.setStyle(this.containerContent, 'marginRight', width);
        }
    };
    MatDrawerRailDirective.prototype.ngOnDestroy = function () {
        this.onDestory.next();
        this.onDestory.complete();
    };
    MatDrawerRailDirective.ctorParameters = function () { return [
        { type: AnimationBuilder },
        { type: ElementRef },
        { type: Renderer2 },
        { type: MatSidenav, decorators: [{ type: Host }, { type: Self }, { type: Optional }] },
        { type: MatDrawer, decorators: [{ type: Host }, { type: Self }, { type: Optional }] },
        { type: MatSidenavContainer, decorators: [{ type: Inject, args: [forwardRef(function () { return MatSidenavContainer; }),] }, { type: Optional }] },
        { type: MatDrawerContainer, decorators: [{ type: Inject, args: [forwardRef(function () { return MatDrawerContainer; }),] }, { type: Optional }] },
        { type: Directionality, decorators: [{ type: Optional }] }
    ]; };
    __decorate([
        Input()
    ], MatDrawerRailDirective.prototype, "openAnimation", void 0);
    __decorate([
        Input()
    ], MatDrawerRailDirective.prototype, "closeAnimation", void 0);
    __decorate([
        Input()
    ], MatDrawerRailDirective.prototype, "closeWidth", void 0);
    __decorate([
        Input()
    ], MatDrawerRailDirective.prototype, "expandedWidth", void 0);
    MatDrawerRailDirective = __decorate([
        Directive({
            // tslint:disable-next-line: directive-selector
            selector: 'mat-sidenav[mode="rail"], mat-drawer[mode="rail"]',
            // tslint:disable-next-line: no-host-metadata-property
            host: {
                '[class.mat-drawer-side]': 'true',
            }
        }),
        __param(3, Host()), __param(3, Self()), __param(3, Optional()),
        __param(4, Host()), __param(4, Self()), __param(4, Optional()),
        __param(5, Inject(forwardRef(function () { return MatSidenavContainer; }))), __param(5, Optional()),
        __param(6, Inject(forwardRef(function () { return MatDrawerContainer; }))), __param(6, Optional()),
        __param(7, Optional())
    ], MatDrawerRailDirective);
    return MatDrawerRailDirective;
}());

var DrawerRailModule = /** @class */ (function () {
    function DrawerRailModule() {
    }
    DrawerRailModule = __decorate([
        NgModule({
            imports: [MatSidenavModule],
            declarations: [MatDrawerRailDirective],
            exports: [MatDrawerRailDirective],
        })
    ], DrawerRailModule);
    return DrawerRailModule;
}());

/*
 * Public API Surface of angular-material-rail-drawer
 */

/**
 * Generated bundle index. Do not edit.
 */

export { DrawerRailModule, MatDrawerRailDirective, miniConfig, sidebarAnimationCloseGroup, sidebarAnimationOpenGroup, sidebarClose, sidebarOpen };
//# sourceMappingURL=angular-material-rail-drawer.js.map
