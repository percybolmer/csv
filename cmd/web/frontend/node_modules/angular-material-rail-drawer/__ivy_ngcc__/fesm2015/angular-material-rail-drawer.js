import { __decorate, __param } from 'tslib';
import { ElementRef, Renderer2, Host, Self, Optional, Inject, forwardRef, Input, Directive, NgModule } from '@angular/core';
import { MatSidenav, MatDrawer, MatSidenavContainer, MatDrawerContainer, MatSidenavModule } from '@angular/material/sidenav';
import { style, group, query, animateChild, animate, AnimationBuilder } from '@angular/animations';
import { Subject } from 'rxjs';
import { takeUntil } from 'rxjs/operators';
import { Directionality } from '@angular/cdk/bidi';

import * as ɵngcc0 from '@angular/core';
import * as ɵngcc1 from '@angular/animations';
import * as ɵngcc2 from '@angular/material/sidenav';
import * as ɵngcc3 from '@angular/cdk/bidi';
const miniConfig = {
    defaultDuration: '100ms',
    defaultMinWidth: '60px',
    defaultMaxWidth: '200px',
};

function sidebarClose(minWidth = miniConfig.defaultMinWidth) {
    return style({
        width: minWidth,
        visibility: 'visible',
        transform: 'none',
        overflow: 'hidden'
    });
}
function sidebarOpen(maxWidth = miniConfig.defaultMaxWidth) {
    return style({
        width: maxWidth,
        visibility: 'visible',
    });
}
function sidebarAnimationOpenGroup(animationDuration = miniConfig.defaultDuration, maxWidth = miniConfig.defaultMaxWidth) {
    return group([
        query('@iconAnimation', animateChild(), { optional: true }),
        query('@labelAnimation', animateChild(), { optional: true }),
        animate(`${animationDuration} ease-in-out`, sidebarOpen(maxWidth))
    ]);
}
function sidebarAnimationCloseGroup(animationDuration = miniConfig.defaultDuration, minWidth = miniConfig.defaultMinWidth) {
    return group([
        query('@iconAnimation', animateChild(), { optional: true }),
        query('@labelAnimation', animateChild(), { optional: true }),
        animate(`${animationDuration} ease-in-out`, sidebarClose(minWidth))
    ]);
}

let MatDrawerRailDirective = class MatDrawerRailDirective {
    constructor(builder, el, renderer2, sidenav, drawer, matSideNavContainer, matDrawerContainer, 
    // tslint:disable-next-line: variable-name
    _dir) {
        this.builder = builder;
        this.el = el;
        this.renderer2 = renderer2;
        this._dir = _dir;
        this.onDestory = new Subject();
        this.closeWidth = miniConfig.defaultMinWidth;
        this.expandedWidth = miniConfig.defaultMaxWidth;
        this.container = matSideNavContainer || matDrawerContainer;
        this.drawer = sidenav || drawer;
        this.container.hasBackdrop = false;
        this.drawer.autoFocus = false;
    }
    ngOnInit() {
        this.closeAnimation = this.closeAnimation || sidebarAnimationCloseGroup(miniConfig.defaultDuration, this.closeWidth);
        this.openAnimation = this.openAnimation || sidebarAnimationOpenGroup(miniConfig.defaultDuration, this.expandedWidth);
        this.renderer2.setStyle(this.el.nativeElement.querySelector('.mat-drawer-inner-container'), 'overflow', 'hidden');
        this.drawer.closedStart.pipe(takeUntil(this.onDestory)).subscribe(() => {
            this.closeMenu();
        });
        this.drawer._closedStream.pipe(takeUntil(this.onDestory)).subscribe(() => {
            this.renderer2.setStyle(this.el.nativeElement, 'visibility', 'visible');
        });
        this.drawer.openedStart.pipe(takeUntil(this.onDestory)).subscribe(() => {
            this.correctContentMargin(this.expandedWidth);
            const factory = this.builder.build(this.openAnimation);
            const player = factory.create(this.el.nativeElement);
            player.play();
        });
    }
    ngAfterViewInit() {
        if (this.drawer.opened) {
            this.correctContentMargin(this.expandedWidth);
        }
        else {
            this.renderer2.setStyle(this.el.nativeElement, 'visibility', 'visible');
            this.closeMenu();
        }
    }
    closeMenu() {
        this.correctContentMargin(this.closeWidth);
        const factory = this.builder.build(this.closeAnimation);
        const player = factory.create(this.el.nativeElement);
        player.play();
    }
    correctContentMargin(width) {
        this.containerContent = this.containerContent ? this.containerContent : this.el.nativeElement.parentElement.querySelector('.mat-drawer-content');
        if ((this.drawer.position !== 'end' && this._dir && this._dir.value !== 'rtl')
            || (this.drawer.position === 'end' && this._dir && this._dir.value === 'rtl')) {
            this.renderer2.setStyle(this.containerContent, 'marginLeft', width);
        }
        else {
            this.renderer2.setStyle(this.containerContent, 'marginRight', width);
        }
    }
    ngOnDestroy() {
        this.onDestory.next();
        this.onDestory.complete();
    }
};
MatDrawerRailDirective.ɵfac = function MatDrawerRailDirective_Factory(t) { return new (t || MatDrawerRailDirective)(ɵngcc0.ɵɵdirectiveInject(ɵngcc1.AnimationBuilder), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.Renderer2), ɵngcc0.ɵɵdirectiveInject(ɵngcc2.MatSidenav, 11), ɵngcc0.ɵɵdirectiveInject(ɵngcc2.MatDrawer, 11), ɵngcc0.ɵɵdirectiveInject(forwardRef(() => MatSidenavContainer), 8), ɵngcc0.ɵɵdirectiveInject(forwardRef(() => MatDrawerContainer), 8), ɵngcc0.ɵɵdirectiveInject(ɵngcc3.Directionality, 8)); };
MatDrawerRailDirective.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: MatDrawerRailDirective, selectors: [["mat-sidenav", "mode", "rail"], ["mat-drawer", "mode", "rail"]], hostVars: 2, hostBindings: function MatDrawerRailDirective_HostBindings(rf, ctx) { if (rf & 2) {
        ɵngcc0.ɵɵclassProp("mat-drawer-side", true);
    } }, inputs: { closeWidth: "closeWidth", expandedWidth: "expandedWidth", closeAnimation: "closeAnimation", openAnimation: "openAnimation" } });
MatDrawerRailDirective.ctorParameters = () => [
    { type: AnimationBuilder },
    { type: ElementRef },
    { type: Renderer2 },
    { type: MatSidenav, decorators: [{ type: Host }, { type: Self }, { type: Optional }] },
    { type: MatDrawer, decorators: [{ type: Host }, { type: Self }, { type: Optional }] },
    { type: MatSidenavContainer, decorators: [{ type: Inject, args: [forwardRef(() => MatSidenavContainer),] }, { type: Optional }] },
    { type: MatDrawerContainer, decorators: [{ type: Inject, args: [forwardRef(() => MatDrawerContainer),] }, { type: Optional }] },
    { type: Directionality, decorators: [{ type: Optional }] }
];
__decorate([
    Input()
], MatDrawerRailDirective.prototype, "openAnimation", void 0);
__decorate([
    Input()
], MatDrawerRailDirective.prototype, "closeAnimation", void 0);
__decorate([
    Input()
], MatDrawerRailDirective.prototype, "closeWidth", void 0);
__decorate([
    Input()
], MatDrawerRailDirective.prototype, "expandedWidth", void 0);
MatDrawerRailDirective = __decorate([ __param(3, Host()), __param(3, Self()), __param(3, Optional()),
    __param(4, Host()), __param(4, Self()), __param(4, Optional()),
    __param(5, Inject(forwardRef(() => MatSidenavContainer))), __param(5, Optional()),
    __param(6, Inject(forwardRef(() => MatDrawerContainer))), __param(6, Optional()),
    __param(7, Optional())
], MatDrawerRailDirective);

let DrawerRailModule = class DrawerRailModule {
};
DrawerRailModule.ɵmod = ɵngcc0.ɵɵdefineNgModule({ type: DrawerRailModule });
DrawerRailModule.ɵinj = ɵngcc0.ɵɵdefineInjector({ factory: function DrawerRailModule_Factory(t) { return new (t || DrawerRailModule)(); }, imports: [[MatSidenavModule]] });
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(MatDrawerRailDirective, [{
        type: Directive,
        args: [{
                // tslint:disable-next-line: directive-selector
                selector: 'mat-sidenav[mode="rail"], mat-drawer[mode="rail"]',
                // tslint:disable-next-line: no-host-metadata-property
                host: {
                    '[class.mat-drawer-side]': 'true'
                }
            }]
    }], function () { return [{ type: ɵngcc1.AnimationBuilder }, { type: ɵngcc0.ElementRef }, { type: ɵngcc0.Renderer2 }, { type: ɵngcc2.MatSidenav, decorators: [{
                type: Host
            }, {
                type: Self
            }, {
                type: Optional
            }] }, { type: ɵngcc2.MatDrawer, decorators: [{
                type: Host
            }, {
                type: Self
            }, {
                type: Optional
            }] }, { type: ɵngcc2.MatSidenavContainer, decorators: [{
                type: Inject,
                args: [forwardRef(() => MatSidenavContainer)]
            }, {
                type: Optional
            }] }, { type: ɵngcc2.MatDrawerContainer, decorators: [{
                type: Inject,
                args: [forwardRef(() => MatDrawerContainer)]
            }, {
                type: Optional
            }] }, { type: ɵngcc3.Directionality, decorators: [{
                type: Optional
            }] }]; }, { closeWidth: [{
            type: Input
        }], expandedWidth: [{
            type: Input
        }], closeAnimation: [{
            type: Input
        }], openAnimation: [{
            type: Input
        }] }); })();
(function () { (typeof ngJitMode === "undefined" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(DrawerRailModule, { declarations: function () { return [MatDrawerRailDirective]; }, imports: function () { return [MatSidenavModule]; }, exports: function () { return [MatDrawerRailDirective]; } }); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(DrawerRailModule, [{
        type: NgModule,
        args: [{
                imports: [MatSidenavModule],
                declarations: [MatDrawerRailDirective],
                exports: [MatDrawerRailDirective]
            }]
    }], null, null); })();

/*
 * Public API Surface of angular-material-rail-drawer
 */

/**
 * Generated bundle index. Do not edit.
 */

export { DrawerRailModule, MatDrawerRailDirective, miniConfig, sidebarAnimationCloseGroup, sidebarAnimationOpenGroup, sidebarClose, sidebarOpen };

//# sourceMappingURL=angular-material-rail-drawer.js.map