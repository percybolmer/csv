import { __decorate, __param } from 'tslib';
import { ElementRef, Renderer2, Host, Self, Optional, Inject, forwardRef, Input, Directive, NgModule } from '@angular/core';
import { MatSidenav, MatDrawer, MatSidenavContainer, MatDrawerContainer, MatSidenavModule } from '@angular/material/sidenav';
import { style, group, query, animateChild, animate, AnimationBuilder } from '@angular/animations';
import { Subject } from 'rxjs';
import { takeUntil } from 'rxjs/operators';
import { Directionality } from '@angular/cdk/bidi';

const miniConfig = {
    defaultDuration: '100ms',
    defaultMinWidth: '60px',
    defaultMaxWidth: '200px',
};

function sidebarClose(minWidth = miniConfig.defaultMinWidth) {
    return style({
        width: minWidth,
        visibility: 'visible',
        transform: 'none',
        overflow: 'hidden'
    });
}
function sidebarOpen(maxWidth = miniConfig.defaultMaxWidth) {
    return style({
        width: maxWidth,
        visibility: 'visible',
    });
}
function sidebarAnimationOpenGroup(animationDuration = miniConfig.defaultDuration, maxWidth = miniConfig.defaultMaxWidth) {
    return group([
        query('@iconAnimation', animateChild(), { optional: true }),
        query('@labelAnimation', animateChild(), { optional: true }),
        animate(`${animationDuration} ease-in-out`, sidebarOpen(maxWidth))
    ]);
}
function sidebarAnimationCloseGroup(animationDuration = miniConfig.defaultDuration, minWidth = miniConfig.defaultMinWidth) {
    return group([
        query('@iconAnimation', animateChild(), { optional: true }),
        query('@labelAnimation', animateChild(), { optional: true }),
        animate(`${animationDuration} ease-in-out`, sidebarClose(minWidth))
    ]);
}

let MatDrawerRailDirective = class MatDrawerRailDirective {
    constructor(builder, el, renderer2, sidenav, drawer, matSideNavContainer, matDrawerContainer, 
    // tslint:disable-next-line: variable-name
    _dir) {
        this.builder = builder;
        this.el = el;
        this.renderer2 = renderer2;
        this._dir = _dir;
        this.onDestory = new Subject();
        this.closeWidth = miniConfig.defaultMinWidth;
        this.expandedWidth = miniConfig.defaultMaxWidth;
        this.container = matSideNavContainer || matDrawerContainer;
        this.drawer = sidenav || drawer;
        this.container.hasBackdrop = false;
        this.drawer.autoFocus = false;
    }
    ngOnInit() {
        this.closeAnimation = this.closeAnimation || sidebarAnimationCloseGroup(miniConfig.defaultDuration, this.closeWidth);
        this.openAnimation = this.openAnimation || sidebarAnimationOpenGroup(miniConfig.defaultDuration, this.expandedWidth);
        this.renderer2.setStyle(this.el.nativeElement.querySelector('.mat-drawer-inner-container'), 'overflow', 'hidden');
        this.drawer.closedStart.pipe(takeUntil(this.onDestory)).subscribe(() => {
            this.closeMenu();
        });
        this.drawer._closedStream.pipe(takeUntil(this.onDestory)).subscribe(() => {
            this.renderer2.setStyle(this.el.nativeElement, 'visibility', 'visible');
        });
        this.drawer.openedStart.pipe(takeUntil(this.onDestory)).subscribe(() => {
            this.correctContentMargin(this.expandedWidth);
            const factory = this.builder.build(this.openAnimation);
            const player = factory.create(this.el.nativeElement);
            player.play();
        });
    }
    ngAfterViewInit() {
        if (this.drawer.opened) {
            this.correctContentMargin(this.expandedWidth);
        }
        else {
            this.renderer2.setStyle(this.el.nativeElement, 'visibility', 'visible');
            this.closeMenu();
        }
    }
    closeMenu() {
        this.correctContentMargin(this.closeWidth);
        const factory = this.builder.build(this.closeAnimation);
        const player = factory.create(this.el.nativeElement);
        player.play();
    }
    correctContentMargin(width) {
        this.containerContent = this.containerContent ? this.containerContent : this.el.nativeElement.parentElement.querySelector('.mat-drawer-content');
        if ((this.drawer.position !== 'end' && this._dir && this._dir.value !== 'rtl')
            || (this.drawer.position === 'end' && this._dir && this._dir.value === 'rtl')) {
            this.renderer2.setStyle(this.containerContent, 'marginLeft', width);
        }
        else {
            this.renderer2.setStyle(this.containerContent, 'marginRight', width);
        }
    }
    ngOnDestroy() {
        this.onDestory.next();
        this.onDestory.complete();
    }
};
MatDrawerRailDirective.ctorParameters = () => [
    { type: AnimationBuilder },
    { type: ElementRef },
    { type: Renderer2 },
    { type: MatSidenav, decorators: [{ type: Host }, { type: Self }, { type: Optional }] },
    { type: MatDrawer, decorators: [{ type: Host }, { type: Self }, { type: Optional }] },
    { type: MatSidenavContainer, decorators: [{ type: Inject, args: [forwardRef(() => MatSidenavContainer),] }, { type: Optional }] },
    { type: MatDrawerContainer, decorators: [{ type: Inject, args: [forwardRef(() => MatDrawerContainer),] }, { type: Optional }] },
    { type: Directionality, decorators: [{ type: Optional }] }
];
__decorate([
    Input()
], MatDrawerRailDirective.prototype, "openAnimation", void 0);
__decorate([
    Input()
], MatDrawerRailDirective.prototype, "closeAnimation", void 0);
__decorate([
    Input()
], MatDrawerRailDirective.prototype, "closeWidth", void 0);
__decorate([
    Input()
], MatDrawerRailDirective.prototype, "expandedWidth", void 0);
MatDrawerRailDirective = __decorate([
    Directive({
        // tslint:disable-next-line: directive-selector
        selector: 'mat-sidenav[mode="rail"], mat-drawer[mode="rail"]',
        // tslint:disable-next-line: no-host-metadata-property
        host: {
            '[class.mat-drawer-side]': 'true',
        }
    }),
    __param(3, Host()), __param(3, Self()), __param(3, Optional()),
    __param(4, Host()), __param(4, Self()), __param(4, Optional()),
    __param(5, Inject(forwardRef(() => MatSidenavContainer))), __param(5, Optional()),
    __param(6, Inject(forwardRef(() => MatDrawerContainer))), __param(6, Optional()),
    __param(7, Optional())
], MatDrawerRailDirective);

let DrawerRailModule = class DrawerRailModule {
};
DrawerRailModule = __decorate([
    NgModule({
        imports: [MatSidenavModule],
        declarations: [MatDrawerRailDirective],
        exports: [MatDrawerRailDirective],
    })
], DrawerRailModule);

/*
 * Public API Surface of angular-material-rail-drawer
 */

/**
 * Generated bundle index. Do not edit.
 */

export { DrawerRailModule, MatDrawerRailDirective, miniConfig, sidebarAnimationCloseGroup, sidebarAnimationOpenGroup, sidebarClose, sidebarOpen };
//# sourceMappingURL=angular-material-rail-drawer.js.map
