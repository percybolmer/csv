// Package databases is generated by Handlergenerator tooling
// Make sure to insert real Description here
package databases

import (
	"context"
	"fmt"
	"strings"

	"github.com/percybolmer/go4data/handlers"
	"github.com/percybolmer/go4data/metric"
	"github.com/percybolmer/go4data/payload"
	"github.com/percybolmer/go4data/property"
	"github.com/percybolmer/go4data/pubsub"
	"github.com/percybolmer/go4data/register"

	elasticsearch6 "github.com/elastic/go-elasticsearch/v6"
	elasticsearch7 "github.com/elastic/go-elasticsearch/v7"
	"github.com/elastic/go-elasticsearch/v8/esapi"
)

// PutElasticSearch is used to push payloads onto a elasticsearch topic
type PutElasticSearch struct {
	// Cfg is values needed to properly run the Handle func
	Cfg *property.Configuration `json:"configs" yaml:"configs"`
	// Name is sort of like an ID used to load data back should be the same that is used to register the Handler
	Name string `json:"handler_name" yaml:"handler_name"`
	// subscriptionless should be set to true if this Handler does not need any input payloads to function
	subscriptionless bool
	// the index to push onto
	index string
	// the ip of the elastic node
	ip string
	// the port of the elastic
	port int
	// elastictype is the type that is set for the input to elasticsearch, used for mapping purpose
	elastictype string

	//errChan is the channel to output errors.
	errChan chan error
	// metrics is a metric.Provider that allows export of metrics
	metrics metric.Provider
	// metricPrefix is a unique string to attach to metrics
	metricPrefix string

	//es6 is for version 6
	es6 *elasticsearch6.Client
	//es 7 is for version 7
	es7 *elasticsearch7.Client
}

func init() {
	register.Register("PutElasticSearch", NewPutElasticSearchHandler)
}

// NewPutElasticSearchHandler generates a new PutElasticSearch Handler
func NewPutElasticSearchHandler() handlers.Handler {
	act := &PutElasticSearch{
		Cfg: &property.Configuration{
			Properties: make([]*property.Property, 0),
		},
		Name:    "PutElasticSearch",
		errChan: make(chan error, 1000),
		metrics: metric.NewPrometheusProvider(),
	}
	act.Cfg.AddProperty("index", "the index to push to", true)
	act.Cfg.AddProperty("ip", "the ip of the elasticserver to connect", true)
	act.Cfg.AddProperty("port", "the port used by the server", true)
	act.Cfg.AddProperty("type", "the elastic type to use, has to be unique to avoid mapping collisions", true)
	act.Cfg.AddProperty("version", "the elastic version to use", true)
	return act
}

// GetHandlerName should return the name of the handler that was used in register
func (a *PutElasticSearch) GetHandlerName() string {
	return a.Name
}

// Handle is used to send the payload []byte to an index as a JSON blobb
func (a *PutElasticSearch) Handle(ctx context.Context, input payload.Payload, topics ...string) error {
	a.metrics.IncrementMetric(fmt.Sprintf("%s_payloads_in", a.metricPrefix), 1)

	req := esapi.IndexRequest{
		Index:   a.index,
		Body:    strings.NewReader(string(input.GetPayload())),
		Refresh: "true",
	}
	if a.es6 != nil {
		res, err := req.Do(ctx, a.es6)
		if err != nil {
			return err
		}
		defer res.Body.Close()
	} else if a.es7 != nil {
		res, err := req.Do(ctx, a.es7)
		if err != nil {
			return err
		}
		defer res.Body.Close()
	}

	if len(topics) != 0 {
		pubsub.PublishTopics(topics, input)
	}
	return nil
}

// ValidateConfiguration is used to see that all needed configurations are assigned before starting
func (a *PutElasticSearch) ValidateConfiguration() (bool, []string) {
	// Check if Cfgs are there as needed
	valid, miss := a.Cfg.ValidateProperties()
	if !valid {
		return valid, miss
	}

	mockProp := a.Cfg.GetProperty("mock")
	var mock bool
	if mockProp != nil {
		mocki, err := mockProp.Bool()
		if err != nil {
			return false, []string{"mock should be true/false"}
		}
		mock = mocki
	}
	indexProp := a.Cfg.GetProperty("index")
	index := indexProp.String()
	if index == "" {
		return false, []string{"cannot have an empty index"}
	}

	typeProp := a.Cfg.GetProperty("type")
	elastictype := typeProp.String()
	if elastictype == "" {
		return false, []string{"cannot use empty type"}
	}
	a.elastictype = elastictype
	ipProp := a.Cfg.GetProperty("ip")
	ip := ipProp.String()
	if ip == "" {
		return false, []string{"cannot use empty ip"}
	}
	portProp := a.Cfg.GetProperty("port")
	port, err := portProp.Int()
	if err != nil {
		return false, []string{err.Error()}
	}

	a.ip = ip
	a.port = port
	a.index = index

	versionProp := a.Cfg.GetProperty("version")
	version := versionProp.String()
	if version == "" {
		return false, []string{"cannot have an empty version, please use 6.X or 7.X"}
	}
	url := fmt.Sprintf("http://%s:%d", ip, port)
	if strings.HasPrefix(version, "7") {
		cfg := elasticsearch7.Config{
			Addresses: []string{
				url,
			},
		}
		es, _ := elasticsearch7.NewClient(cfg)
		a.es7 = es
		a.es6 = nil
	} else if strings.HasPrefix(version, "6") {
		cfg := elasticsearch6.Config{
			Addresses: []string{
				url,
			},
		}
		es6, _ := elasticsearch6.NewClient(cfg)
		a.es6 = es6
		a.es7 = nil
	} else {
		a.es6 = nil
		a.es7 = nil
		return false, []string{"unsupported version"}
	}
	// Make sure connection works
	if !mock {
		if a.es6 != nil {
			_, err := a.es6.Info()
			if err != nil {
				return false, []string{err.Error()}
			}
		} else if a.es7 != nil {
			_, err := a.es7.Info()
			if err != nil {
				return false, []string{err.Error()}
			}
		}
	}
	return true, nil
}

// GetConfiguration will return the CFG for the Handler
func (a *PutElasticSearch) GetConfiguration() *property.Configuration {
	return a.Cfg
}

// Subscriptionless will return true/false if the Handler is genereating payloads itself
func (a *PutElasticSearch) Subscriptionless() bool {
	return a.subscriptionless
}

// GetErrorChannel will return a channel that the Handler can output eventual errors onto
func (a *PutElasticSearch) GetErrorChannel() chan error {
	return a.errChan
}

// SetMetricProvider is used to change what metrics provider is used by the handler
func (a *PutElasticSearch) SetMetricProvider(p metric.Provider, prefix string) error {
	a.metrics = p
	a.metricPrefix = prefix

	// Here you can add Metrics that you want to be stored, should return error if the metric collides with another metric from ANY handler.
	err := a.metrics.AddMetric(&metric.Metric{
		Name:        fmt.Sprintf("%s_payloads_in", prefix),
		Description: "keeps track of how many payloads the handler has ingested",
	})
	return err

}
