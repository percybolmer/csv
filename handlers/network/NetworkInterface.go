// Package network is generated by Handlergenerator tooling
// Make sure to insert real Description here
package network

import (
	"context"
	"errors"
	"fmt"

	"github.com/google/gopacket"
	"github.com/google/gopacket/pcap"
	"github.com/percybolmer/go4data/handlers"
	"github.com/percybolmer/go4data/metric"
	"github.com/percybolmer/go4data/payload"
	"github.com/percybolmer/go4data/property"
	"github.com/percybolmer/go4data/pubsub"
	"github.com/percybolmer/go4data/register"
)

var (
	//ErrNoDevicesFound is when the system has no network interfaces to sniff on
	ErrNoDevicesFound = errors.New("no sniffable devices found on the system")
	//ErrConfiguredInterface is thrown when the wanted interface does not exist
	ErrConfiguredInterface = errors.New("there is no such interface, try checking your systems network interfaces names")
)

// NetworkInterface is used to read packets from a network interface
type NetworkInterface struct {
	// Cfg is values needed to properly run the Handle func
	Cfg *property.Configuration `json:"configs" yaml:"configs"`
	// Name is sort of like an ID used to load data back should be the same that is used to register the Handler
	Name string `json:"handler_name" yaml:"handler_name"`
	// subscriptionless should be set to true if this Handler does not need any input payloads to function
	subscriptionless bool
	// bpf is used to apply a bpf filter
	bpf string
	// netinterface is the network interface to read from
	netinterface *pcap.Interface
	// snapshotlength
	snapshotlength int32
	// link layer
	// prommode
	prommode bool

	errChan      chan error
	metrics      metric.Provider
	metricPrefix string
	// MetricPayloadOut is how many payloads the processor has outputted
	MetricPayloadOut string
	// MetricPayloadIn is how many payloads the processor has inputted
	MetricPayloadIn string
}

func init() {
	register.Register("NetworkInterface", NewNetworkInterfaceHandler)
}

// NewNetworkInterfaceHandler generates a new NetworkInterface Handler
func NewNetworkInterfaceHandler() handlers.Handler {
	act := &NetworkInterface{
		Cfg: &property.Configuration{
			Properties: make([]*property.Property, 0),
		},
		Name:             "NetworkInterface",
		subscriptionless: true,
		snapshotlength:   65536,
		prommode:         true,
		errChan:          make(chan error, 1000),
	}

	act.Cfg.AddProperty("bpf", "A bpf filter to be used on the input interface", false)
	act.Cfg.AddProperty("snapshotlength", "The snapshot length to use", false)
	act.Cfg.AddProperty("promiscuousmode", "True or false to use promiscuous mode", false)

	act.Cfg.AddProperty("interface", "The interface to read network traffic from", true)
	return act
}

// GetHandlerName should return the name of the handler that was used in register
func (a *NetworkInterface) GetHandlerName() string {
	return a.Name
}

// Handle is used to sniff network packets on a interface and output all packets
func (a *NetworkInterface) Handle(ctx context.Context, input payload.Payload, topics ...string) error {
	// Start processing our packets

	handle, err := pcap.OpenLive(a.netinterface.Name, a.snapshotlength, a.prommode, pcap.BlockForever)
	if err != nil {
		return fmt.Errorf("Error opening device %s: %v", a.netinterface.Name, err)
	}
	err = handle.SetBPFFilter(a.bpf)
	if err != nil {
		return err
	}

	packets := gopacket.NewPacketSource(handle, handle.LinkType())
	for {
		packet, err := packets.NextPacket()
		if err != nil {
			a.errChan <- err
			continue
		}
		a.metrics.IncrementMetric(a.MetricPayloadOut, 1)
		// Maybe instead of publishing like this we might need to make a buffer of some sort
		// that gets dumped from into a new routine so we dont block each packet
		newpay := &payload.NetworkPayload{
			Source:  "NetworkInterface",
			Payload: packet,
		}
		errs := pubsub.PublishTopics(topics, newpay)
		if errs != nil {
			for _, err := range errs {
				a.errChan <- err
			}
		}
	}
}

// ValidateConfiguration is used to see that all needed configurations are assigned before starting
func (a *NetworkInterface) ValidateConfiguration() (bool, []string) {
	// Check if Cfgs are there as needed
	bpfProp := a.Cfg.GetProperty("bpf")
	if bpfProp != nil && bpfProp.Value != nil {
		a.bpf = bpfProp.String()
	}
	interfaceProp := a.Cfg.GetProperty("interface")
	if interfaceProp == nil || interfaceProp.Value == nil {
		return false, []string{"Missing interface property"}
	}
	wantedInterface := interfaceProp.String()
	availableInterfaces, err := FindDevices()
	fmt.Println(availableInterfaces)
	if err != nil {
		return false, []string{err.Error()}
	}
	for _, interf := range availableInterfaces {
		if interf.Name == wantedInterface {
			a.netinterface = &interf
			break
		}
	}
	if a.netinterface == nil {
		return false, []string{ErrConfiguredInterface.Error()}
	}

	promModeProp := a.Cfg.GetProperty("promiscuousmode")
	if promModeProp != nil && promModeProp.Value != nil {
		promMode, err := promModeProp.Bool()
		if err != nil {
			return false, []string{err.Error()}
		}
		a.prommode = promMode
	}
	snapshotLenProp := a.Cfg.GetProperty("snapshotlength")
	if snapshotLenProp != nil && snapshotLenProp.Value != nil {
		snaplen, err := snapshotLenProp.Int64()
		if err != nil {
			return false, []string{err.Error()}
		}
		a.snapshotlength = int32(snaplen)
	}

	return true, nil
}

// GetConfiguration will return the CFG for the Handler
func (a *NetworkInterface) GetConfiguration() *property.Configuration {
	return a.Cfg
}

// Subscriptionless will return true/false if the Handler is genereating payloads itself
func (a *NetworkInterface) Subscriptionless() bool {
	return a.subscriptionless
}

// FindDevices prints all network interface info
func FindDevices() ([]pcap.Interface, error) {
	devices, err := pcap.FindAllDevs()
	if err != nil {
		return nil, err
	}
	if len(devices) == 0 {
		return nil, ErrNoDevicesFound
	}
	return devices, nil
}

// GetErrorChannel will return a channel that the Handler can output eventual errors onto
func (a *NetworkInterface) GetErrorChannel() chan error {
	return a.errChan
}

// SetMetricProvider is used to change what metrics provider is used by the handler
func (a *NetworkInterface) SetMetricProvider(p metric.Provider, prefix string) error {
	a.metrics = p
	a.metricPrefix = prefix

	a.MetricPayloadIn = fmt.Sprintf("%s_payloads_in", prefix)
	a.MetricPayloadOut = fmt.Sprintf("%s_payloads_out", prefix)
	err := a.metrics.AddMetric(&metric.Metric{
		Name:        a.MetricPayloadOut,
		Description: "keeps track of how many payloads the handler has outputted",
	})
	if err != nil {
		return err
	}
	err = a.metrics.AddMetric(&metric.Metric{
		Name:        a.MetricPayloadIn,
		Description: "keeps track of how many payloads the handler has ingested",
	})
	return err
}
