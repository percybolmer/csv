// Package {{.PackageName}} is generated by Handlergenerator tooling
// Make sure to insert real Description here
package {{.PackageName}}


import (
    "fmt"
	"github.com/percybolmer/go4data/payload"
	"github.com/percybolmer/go4data/property"
	"github.com/percybolmer/go4data/register"

)

// {{.HandlerName}} is used to $INSERT DESCRIPTION
type {{.HandlerName}} struct{
	// Cfg is values needed to properly run the Handle func
	Cfg *property.Configuration `json:"configs" yaml:"configs"`
	// Name is sort of like an ID used to load data back should be the same that is used to register the Handler
	Name string `json:"handler_name" yaml:"handler_name"`
	// subscriptionless should be set to true if this Handler does not need any input payloads to function
	subscriptionless bool
	//errChan is the channel to output errors.
	errChan chan error
	// metrics is a metric.Provider that allows export of metrics
	metrics metric.Provider
	// metricPrefix is a unique string to attach to metrics
	metricPrefix string
}

func init() {
	register.Register("{{.HandlerName}}", New{{.HandlerName}}Handler)
}

// New{{.HandlerName}}Handler generates a new {{.HandlerName}} Handler
func New{{.HandlerName}}Handler() handlers.Handler {
	act := &{{.HandlerName}}{
		Cfg: &property.Configuration{
			Properties: make([]*property.Property, 0),
		},
		Name: "{{.HandlerName}}",
		errChan: make(chan error, 1000),
		metrics: metric.NewPrometheusProvider(),
	}
	act.Cfg.AddProperty("test", "the configuration you need", true)
	return act
}

// GetHandlerName should return the name of the handler that was used in register
func (a *{{.HandlerName}}) GetHandlerName() string {
	return a.Name
}

// Handle is used to $INSERT DESCRIPTION HERE
func (a *{{.HandlerName}}) Handle(ctx context.Context, input payload.Payload, topics ...string) error {
	fmt.Println(input)
	return nil
}

// ValidateConfiguration is used to see that all needed configurations are assigned before starting
func (a *{{.HandlerName}}) ValidateConfiguration() (bool, []string) {
	// Check if Cfgs are there as needed
	valid, miss := a.Cfg.ValidateProperties()
	if !valid {
		return valid, miss
	}
	return true, nil
}

// GetConfiguration will return the CFG for the Handler
func (a *{{.HandlerName}}) GetConfiguration() *property.Configuration {
	return a.Cfg
}

// Subscriptionless will return true/false if the Handler is genereating payloads itself
func (a *{{.HandlerName}}) Subscriptionless() bool {
	return a.subscriptionless
}
// GetErrorChannel will return a channel that the Handler can output eventual errors onto
func (a *{{.HandlerName}}) GetErrorChannel() chan error {
	return a.errChan
}
// SetMetricProvider is used to change what metrics provider is used by the handler
func (a *{{.HandlerName}}) SetMetricProvider(p metric.Provider, prefix string) error{
	a.metrics = p
	a.metricPrefix = prefix

	// Here you can add Metrics that you want to be stored, should return error if the metric collides with another metric from ANY handler.
	err := a.metrics.AddMetric(&metric.Metric{
		Name:        fmt.Sprintf("%s_payloads_out", prefix),
		Description: "keeps track of how many payloads the handler has outputted",
	})
	return err

}